package generator

const handlerTemplateString = `package {{.Package}}
// Code generated by rest_rpc. DO NOT EDIT.

import (
{{range .Imports}}	{{.}}
{{end}}
)


{{ $errs := .Errors }}

{{range .Services}}{{$serviceName := .Name}}
const {{.Name}}RoutePattern = "{{.Prefix}}/{{.Name}}"


func Register{{$serviceName}}(instance {{$serviceName}}, r *chi.Mux, log logrus.FieldLogger) {
	r.Route("{{.Prefix}}/{{.Name}}", func(r chi.Router) {{"{"}}{{range .Endpoints}}
{{- if .IsPost }}
		r.Post("/{{.Name}}", func(writer http.ResponseWriter, request *http.Request) {
{{- else }}
		r.Get("/{{.Name}}", func(writer http.ResponseWriter, request *http.Request) {
{{- end }}
{{- if .IsControl }}
	writer.WriteHeader(http.StatusOK)
{{- else }}
{{range .Parameters}}			
{{- if ne .ParamType 4}}// Reading argument {{.Name}}
{{if and (ne .ParamType 3) (ne .ParamType 7)}}			{{.Name}}{{if ne .ParamType 1}}Str{{end}} := request.URL.Query().Get("{{.Name}}")
{{end}}
{{- end}}{{if eq .ParamType 0}}			{{.Name}}, err := strconv.Atoi({{.Name}}Str)
			if err != nil {
				log.WithError(err).Errorf("Could not parse {{.Name}} parameter value. Expected integer got %s", {{.Name}}Str)
				writer.WriteHeader(http.StatusBadRequest)
				return
			}

{{end}}{{if eq .ParamType 2}}			{{.Name}}, err := strconv.ParseBool({{.Name}}Str)
			if err != nil {
				log.WithError(err).Errorf("Could not parse {{.Name}} parameter value. Expected bool got %s", {{.Name}}Str)
				writer.WriteHeader(http.StatusBadRequest)
				return
			}


{{end}}{{if eq .ParamType 6}}			{{.Name}}, err := strconv.ParseFloat({{.Name}}Str, 64)
			if err != nil {
				log.WithError(err).Errorf("Could not parse {{.Name}} parameter value. Expected float got %s", {{.Name}}Str)
				writer.WriteHeader(http.StatusBadRequest)
				return
			}

{{end}}{{if eq .ParamType 7}}			{{.Name}} := request.Context()
{{end}}{{if eq .ParamType 3}}			rawBody, err := ioutil.ReadAll(request.Body)
			if err != nil {
				log.WithError(err).Error("can't read body")
				writer.WriteHeader(http.StatusBadRequest)
				return
			}
			var {{.Name}} *{{.TypeName}}
			if len(rawBody) != 0 {
				{{.Name}} = &{{.TypeName}}{}
				if err := json.Unmarshal(rawBody, {{.Name}}); err != nil {
					log.WithError(err).Error("can't unmarshal body")
					writer.WriteHeader(http.StatusBadRequest)
					return
				}
			}

{{end}}{{if eq .ParamType 5}}			{{.Name}}, err := uuid.FromString({{.Name}}Str)
			if err != nil {
				log.WithError(err).Error("can't parse uuid")
				writer.WriteHeader(http.StatusBadRequest)
				return
			}
{{end}}{{end}}			// Calling function {{.Name}}
			{
				{{- $hasTransaction := .HasTransaction -}}
				{{- if .Results}}
				{{range $i, $r := .Results}}{{if gt $i 0}}, {{end}}{{if eq $r 0}}responseCode{{end}}{{if eq $r 1}}err{{end}}{{if eq $r 2}}response{{end}}{{if eq $r 3}}transaction{{end}}{{if eq $r 4}}transaction{{end}}{{if eq $r 5}}cfg{{end}}{{end}} := instance.{{.Name}}({{range $i, $p := .Parameters}}{{if gt $i 0}}, {{end}}{{$p.Name}}{{end}}){{$hasResponseCode := false}}{{$results := .Results}}{{range .Results}}{{if eq . 0}}
				{{if not $hasTransaction}}writer.WriteHeader(responseCode){{$hasResponseCode = true}}{{end}}{{end}}{{end}}
				{{- if .HasTransaction }}
				responseCode, data := common.HandleResponse(response, log, transaction, err)
				writer.WriteHeader(responseCode)
				_, err = writer.Write(data)
				if err != nil {
					log.WithError(err).Error("Could not write error response")
				}
				{{- else }}
				{{- range .Results}}{{if eq . 1}}
				if err != nil {{"{"}}{{if not $hasResponseCode}}
					writer.WriteHeader(http.StatusInternalServerError){{end}}
					if err := json.NewEncoder(writer).Encode(&struct{Error string}{Error: err.Error()}); err != nil {
						fmt.Fprintf(writer, "{\"Error\": \"Could not marshal response error\"}")
						log.WithError(err).Error("Could not marshal response error")
					}
					return
				}{{end}}{{end}}{{range .Results}}{{if or (eq . 2) (eq . 5)}}
				{{- $name := ""}}
				{{- if eq . 2 }} {{$name = "response"}} {{- end}}
				{{- if eq . 5 }} {{$name = "cfg"}} {{- end}}
				if {{$name}} != nil {
					if err := json.NewEncoder(writer).Encode({{$name}}); err != nil {
						log.WithError(err).Error("Could not write {{$name}}")
						writer.WriteHeader(http.StatusInternalServerError)
						if err := json.NewEncoder(writer).Encode(&struct{Error string}{Error: err.Error()}); err != nil {
							fmt.Fprintf(writer, "{\"Error\": \"Could not marshal response error\"}")
							log.WithError(err).Error("Could not marshal response error")
						}
						return
					}
				}{{end}}{{end}}{{end}}{{end}}
			}{{end}}
		}){{end}}
	})
}

type {{.Name}}RestClient struct {
	address      string
	client       http_client.DefaultHTTPClient
	errs         []error
}

func New{{.Name}}RestClient(address string, client http_client.DefaultHTTPClient) (*{{.Name}}RestClient, error) {
	packageErrors := []error{ {{range $i, $err := $errs}} {{if gt $i 0}}, {{end}}{{$err}}{{end}} }
	
	restClient := &{{.Name}}RestClient{
		address: address,
		client: client,
		errs: packageErrors,
	}
	
	// restClient is returned to avoid panics, some services may work without working rest client
	if code := restClient.isUp(); code != http.StatusOK {
		return restClient, http_server.ServerNotUp
	}
	return restClient, nil
}


func New{{.Name}}RestClientErrWrap(address string, client http_client.DefaultHTTPClient, log logrus.FieldLogger) *{{.Name}}RestClient {
	restClient, err := New{{.Name}}RestClient(address, client)
	if err != nil {
		log.WithError(err).Warn("failed to create {{.Name}}RestClient")
	}
	return restClient
}

func (serviceInstance *{{$serviceName}}RestClient) wrapError(errMsg interface{}) error {
	for _, er := range serviceInstance.errs {
		if strings.EqualFold(errMsg.(string), er.Error()) {
			return er
		}
	}
	return fmt.Errorf("%v", errMsg)
}

